<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Infinite Terrain</title>
    <meta name="description" content="Expand your world in this infinite tile-based map building game. Place cards, discover events, and create your own unique landscape!">
    <style>
        body, html {
            margin: 0;
            padding: 0;
            height: 100%;
            font-family: Arial, sans-serif;
            overflow: hidden;
            transition: background-color 10s;
        }
        #gameContainer {
            position: relative;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }
        #gameCanvas {
            position: absolute;
            top: 0;
            left: 0;
            touch-action: none;
        }
        #hand {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 5px;
            z-index: 10;
            background-color: rgba(255, 255, 255, 0.8);
            border-radius: 5px;
            padding: 5px;
        }
        .card {
            width: 25px;
            height: 40px;
            background-color: #f0f0f0;
            border: 1px solid #333;
            border-radius: 3px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 16px;
            cursor: pointer;
        }
        #eventLog {
            width: 150px;
            height: 100px;
            background-color: rgba(255, 255, 255, 0.8);
            border: 1px solid #333;
            padding: 5px;
            overflow-y: auto;
            font-size: 12px;
        }
        #startMenu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(255, 255, 255, 0.9);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            z-index: 100;
        }
        #readyButton {
            margin-top: 20px;
            padding: 10px 20px;
            font-size: 18px;
            cursor: pointer;
        }
        .popup {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: white;
            border: 2px solid #333;
            border-radius: 10px;
            padding: 20px;
            z-index: 1000;
            display: none;
        }
        .popupContent {
            margin-bottom: 20px;
        }
        .closeButton {
            position: absolute;
            top: 5px;
            right: 5px;
            font-size: 20px;
            cursor: pointer;
            background: none;
            border: none;
        }
        .actionButton {
            display: block;
            margin: 0 auto;
            padding: 10px 20px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        #resourceBar {
            position: absolute;
            top: 0;
            left: 0;
            width: 40px;
            height: 100%;
            background-color: rgba(255, 255, 255, 0.8);
            display: flex;
            flex-direction: column;
            overflow-y: auto;
            z-index: 10;
        }
        .resourceCard {
            width: 30px;
            height: 30px;
            margin: 5px;
            background-color: #f0f0f0;
            border: 1px solid #333;
            border-radius: 5px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-size: 12px;
            cursor: move;
        }
        #topRightDock {
            position: absolute;
            top: 10px;
            right: 10px;
            width: auto;
            height: auto;
            background-color: rgba(255, 255, 255, 0.8);
            border-radius: 5px;
            padding: 5px;
            display: flex;
            flex-direction: column;
            align-items: center;
            z-index: 10;
        }
        #buttonRow {
            display: flex;
            justify-content: center;
            margin-bottom: 5px;
        }
        #forgeCard, #moveTileButton, #collectAllButton, #roadBuildingButton {
            width: 30px;
            height: 30px;
            margin: 0 5px;
            background-color: #f0f0f0;
            border: 1px solid #333;
            border-radius: 5px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 16px;
            cursor: pointer;
        }
        .forgeSlot {
            width: 40px;
            height: 40px;
            border: 2px dashed #333;
            border-radius: 5px;
            margin: 10px;
            display: inline-block;
        }
        #forgeButton {
            display: block;
            margin: 20px auto 0;
            padding: 10px 20px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 20px;
        }
        #gameClock {
            margin-top: 10px;
            background-color: rgba(255, 255, 255, 0.8);
            border-radius: 5px;
            padding: 5px 10px;
            font-size: 18px;
            z-index: 10;
        }
        #avatarPopup {
            display: flex;
            justify-content: space-between;
            width: 80%;
            max-width: 800px;
        }
        #avatarList {
            width: 45%;
            overflow-y: auto;
            max-height: 300px;
        }
        #avatarStats {
            width: 45%;
        }
        .avatarCard {
            background-color: #f0f0f0;
            border: 1px solid #333;
            border-radius: 5px;
            padding: 5px;
            margin-bottom: 5px;
            cursor: pointer;
        }
        .avatarCard.selected {
            background-color: #d0d0d0;
        }
        #combatPopup {
            text-align: center;
        }
        #combatLog {
            margin-top: 10px;
            max-height: 200px;
            overflow-y: auto;
        }
        #recipesPopup {
            max-height: 80%;
            overflow-y: auto;
        }
        #saveLoadPopup {
            text-align: center;
        }
        #saveLoadPopup button {
            margin: 10px;
            padding: 10px 20px;
        }
        #recipeButton {
            position: absolute;
            top: 5px;
            left: 5px;
            font-size: 20px;
            cursor: pointer;
            background: none;
            border: none;
        }
        #clearForgeButton {
            position: absolute;
            top: 5px;
            left: 35px;
            font-size: 20px;
            cursor: pointer;
            background: none;
            border: none;
        }
        #avatarEquipment {
            margin-top: 10px;
            max-height: 100px;
            overflow-y: auto;
        }
        .equipmentButton {
            margin: 5px;
            padding: 5px 10px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <div id="hand"></div>
        <div id="startMenu">
            <h2>Infinite Terrain</h2>
            <p>Controls:</p>
            <ul>
                <li>Click and drag or touch and move to pan the map</li>
                <li>Pinch or use mouse wheel to zoom in/out</li>
                <li>Click on a card in your hand, then click on the map to place it</li>
                <li>Click on a placed tile for more information and to collect resources</li>
            </ul>
            <button id="readyButton">Ready</button>
        </div>
        <div id="popupBox" class="popup">
            <button class="closeButton">&times;</button>
            <div id="popupContent" class="popupContent"></div>
            <button id="collectButton" class="actionButton">Collect Resources</button>
        </div>
        <div id="resourceBar"></div>
        <div id="topRightDock">
            <div id="buttonRow">
                <div id="forgeCard">‚öíÔ∏è</div>
                <div id="moveTileButton">üëã</div>
                <div id="collectAllButton">‚≠ï</div>
                <div id="roadBuildingButton">üõ£Ô∏è</div>
            </div>
            <div id="eventLog"></div>
            <div id="gameClock"></div>
        </div>
        <div id="forgePopup" class="popup">
            <button class="closeButton">&times;</button>
            <button id="recipeButton">‚ùì</button>
            <button id="clearForgeButton">üßπ</button>
            <div class="forgeSlot" id="forgeSlot1"></div>
            <div class="forgeSlot" id="forgeSlot2"></div>
            <div class="forgeSlot" id="forgeSlot3"></div>
            <button id="forgeButton">‚öíÔ∏è</button>
        </div>
        <div id="avatarPopup" class="popup">
            <button class="closeButton">&times;</button>
            <div id="avatarList"></div>
            <div id="avatarStats"></div>
        </div>
        <div id="combatPopup" class="popup">
            <button class="closeButton">&times;</button>
            <h3>Monster Camp Combat</h3>
            <p id="monsterCount"></p>
            <div id="avatarSelection"></div>
            <button id="startCombatButton" class="actionButton">Start Combat</button>
            <div id="combatLog"></div>
            <button id="collectRewardButton" class="actionButton" style="display: none;">Collect Reward</button>
        </div>
        <div id="recipesPopup" class="popup">
            <button class="closeButton">&times;</button>
            <h3>Crafting Recipes</h3>
            <div id="recipesList"></div>
        </div>
        <div id="saveLoadPopup" class="popup">
            <button class="closeButton">&times;</button>
            <h3>Save/Load Game</h3>
            <button id="saveButton">Save Game</button>
            <button id="loadButton">Load Game</button>
            <button id="newGameButton">New Game</button>
            <input type="file" id="loadFile" style="display: none;">
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const hand = document.getElementById('hand');
        const eventLog = document.getElementById('eventLog');
        const startMenu = document.getElementById('startMenu');
        const readyButton = document.getElementById('readyButton');
        const popupBox = document.getElementById('popupBox');
        const popupContent = document.getElementById('popupContent');
        const collectButton = document.getElementById('collectButton');
        const resourceBar = document.getElementById('resourceBar');
        const forgeCard = document.getElementById('forgeCard');
        const forgePopup = document.getElementById('forgePopup');
        const forgeButton = document.getElementById('forgeButton');
        const gameClock = document.getElementById('gameClock');
        const moveTileButton = document.getElementById('moveTileButton');
        const avatarPopup = document.getElementById('avatarPopup');
        const avatarList = document.getElementById('avatarList');
        const avatarStats = document.getElementById('avatarStats');
        const collectAllButton = document.getElementById('collectAllButton');
        const roadBuildingButton = document.getElementById('roadBuildingButton');
        const combatPopup = document.getElementById('combatPopup');
        const monsterCountElement = document.getElementById('monsterCount');
        const avatarSelectionElement = document.getElementById('avatarSelection');
        const startCombatButton = document.getElementById('startCombatButton');
        const combatLogElement = document.getElementById('combatLog');
        const collectRewardButton = document.getElementById('collectRewardButton');
        const recipesPopup = document.getElementById('recipesPopup');
        const recipesList = document.getElementById('recipesList');
        const saveLoadPopup = document.getElementById('saveLoadPopup');
        const saveButton = document.getElementById('saveButton');
        const loadButton = document.getElementById('loadButton');
        const newGameButton = document.getElementById('newGameButton');
        const loadFile = document.getElementById('loadFile');
        const recipeButton = document.getElementById('recipeButton');
        const clearForgeButton = document.getElementById('clearForgeButton');

        let gameStarted = false;
        let mapData = {};
        let cameraOffset = { x: 0, y: 0 };
        let cameraZoom = 1;
        let isDragging = false;
        let lastZoomPinchDistance = 0;
        let dragStart = { x: 0, y: 0 };
        let tileSize = 50;
        let selectedCard = null;
        let resources = {};
        let gameTime = 0;
        let lastUpdateTime = Date.now();
        let avatars = [];
        let lastCollectAllTime = 0;
        let isRoadBuildingMode = false;
        let roadStartTile = null;
        let roadEndTile = null;
        let isMoveTileMode = false;
        let tileToMove = null;

        const terrainTypes = [
            { emoji: 'üè∞', name: 'Castle', resource: 'Royalty' },
            { emoji: 'üå≥', name: 'Enchanted Forest', resource: 'Magic Wood' },
            { emoji: '‚õ∞Ô∏è', name: 'Mystic Mountains', resource: 'Mithril' },
            { emoji: 'üåæ', name: 'Elven Fields', resource: 'Elven Wheat' },
            { emoji: 'üèñÔ∏è', name: 'Mermaid Cove', resource: 'Pearls' },
            { emoji: 'üåä', name: 'Dragon Sea', resource: 'Dragon Scales' },
            { emoji: 'üèúÔ∏è', name: 'Sandworm Desert', resource: 'Spice' },
            { emoji: 'üåã', name: 'Phoenix Volcano', resource: 'Phoenix Feathers' },
            { emoji: 'üçÑ', name: 'Fairy Mushroom Grove', resource: 'Fairy Dust' },
            { emoji: '‚ùÑÔ∏è', name: 'Frost Giant Tundra', resource: 'Ice Crystals' },
            { emoji: 'üï≥Ô∏è', name: 'Dwarven Mines', resource: 'Precious Gems' },
            { emoji: 'üèõÔ∏è', name: 'Ancient Ruins', resource: 'Ancient Artifacts' }
        ];

        const events = [
            { emoji: 'üè†', name: 'Town', description: 'You found a town! Trade for more cards.' },
            { emoji: 'üëø', name: 'Monster Camp', description: 'A monster settlement! Defeat them for rewards.' },
            { emoji: 'üèõÔ∏è', name: 'Ruins', description: 'Ancient ruins discovered. Explore for treasures!' }
        ];

        const recipes = [
            { inputs: ['Magic Wood', 'Mithril'], output: 'Enchanted Tool', outputEmoji: 'üîÆ' },
            { inputs: ['Elven Wheat', 'Dragon Scales'], output: 'Dragon Bread', outputEmoji: 'üçû' },
            { inputs: ['Pearls', 'Phoenix Feathers'], output: 'Phoenix Pearl', outputEmoji: 'üî•' },
            { inputs: ['Spice', 'Ice Crystals'], output: 'Frost Spice', outputEmoji: '‚ùÑÔ∏è' },
            { inputs: ['Precious Gems', 'Fairy Dust'], output: 'Fairy Jewels', outputEmoji: 'üíé' },
            { inputs: ['Ancient Artifacts', 'Magic Wood'], output: 'Mystic Artifact', outputEmoji: 'üìú' },
            { inputs: ['Royalty', 'Dragon Scales'], output: 'Dragon Crown', outputEmoji: 'üëë' },
            { inputs: ['Mithril', 'Precious Gems'], output: 'Mithril Jewelry', outputEmoji: 'üíç' },
            { inputs: ['Phoenix Feathers', 'Ice Crystals'], output: 'Elemental Orb', outputEmoji: 'üîÆ' },
            { inputs: ['Fairy Dust', 'Elven Wheat'], output: 'Fairy Bread', outputEmoji: 'üßö' },
            { inputs: ['Spice', 'Dragon Scales'], output: 'Dragon Spice', outputEmoji: 'üêâ' },
            { inputs: ['Pearls', 'Magic Wood'], output: 'Mermaid Wand', outputEmoji: 'üßú' },
            { inputs: ['Ancient Artifacts', 'Mithril'], output: 'Legendary Weapon', outputEmoji: '‚öîÔ∏è' },
            { inputs: ['Royalty', 'Precious Gems'], output: 'Royal Scepter', outputEmoji: 'üè∞' },
            { inputs: ['Ice Crystals', 'Magic Wood'], output: 'Frost Staff', outputEmoji: 'üßô' },
            { inputs: ['Fairy Dust', 'Phoenix Feathers'], output: 'Magic Potion', outputEmoji: 'üß™' },
            { inputs: ['Spice', 'Elven Wheat'], output: 'Elven Bread', outputEmoji: 'ü•ñ' },
            { inputs: ['Dragon Scales', 'Mithril'], output: 'Dragon Armor', outputEmoji: 'üõ°Ô∏è' },
            { inputs: ['Pearls', 'Fairy Dust'], output: 'Fairy Pearl', outputEmoji: '‚ú®' },
            { inputs: ['Ancient Artifacts', 'Ice Crystals'], output: 'Frozen Relic', outputEmoji: 'üóø' }
        ];

        const avatarEmojis = ['üßô', 'üßù', 'üßõ', 'üßö', 'ü¶Ñ', 'üêâ', 'ü¶π', 'üßû', 'üßü', 'üßú'];

        const clockEmojis = [
            'üïõ', 'üïê', 'üïë', 'üïí', 'üïì', 'üïî', 'üïï', 'üïñ', 'üïó', 'üïò', 'üïô', 'üïö',
            'üïß', 'üïú', 'üïù', 'üïû', 'üïü', 'üï†', 'üï°', 'üï¢', 'üï£', 'üï§', 'üï•', 'üï¶'
        ];

        const tileResourceCombinations = {
            'Dragon Sea': ['Mermaid Cove', 'Phoenix Volcano'],
            'Mermaid Cove': ['Dragon Sea', 'Elven Fields'],
            'Elven Fields': ['Mermaid Cove', 'Enchanted Forest'],
            'Enchanted Forest': ['Elven Fields', 'Mystic Mountains'],
            'Mystic Mountains': ['Enchanted Forest', 'Phoenix Volcano'],
            'Phoenix Volcano': ['Mystic Mountains', 'Sandworm Desert'],
            'Sandworm Desert': ['Phoenix Volcano', 'Elven Fields'],
            'Castle': ['Enchanted Forest', 'Mystic Mountains'],
            'Fairy Mushroom Grove': ['Enchanted Forest', 'Elven Fields'],
            'Frost Giant Tundra': ['Mystic Mountains', 'Dragon Sea'],
            'Dwarven Mines': ['Mystic Mountains', 'Phoenix Volcano'],
            'Ancient Ruins': ['Sandworm Desert', 'Enchanted Forest']
        };

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            drawMap();
            updateResourceBar();
        }

        function initGame() {
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            window.addEventListener('orientationchange', resizeCanvas);
            canvas.addEventListener('mousedown', onMouseDown);
            canvas.addEventListener('mousemove', onMouseMove);
            canvas.addEventListener('mouseup', onMouseUp);
            canvas.addEventListener('wheel', onWheel);
            canvas.addEventListener('click', onCanvasClick);
            canvas.addEventListener('touchstart', onTouchStart);
            canvas.addEventListener('touchmove', onTouchMove);
            canvas.addEventListener('touchend', onTouchEnd);

            dealCards(7);

            document.querySelectorAll('.closeButton').forEach(button => {
                button.addEventListener('click', () => {
                    button.closest('.popup').style.display = 'none';
                });
            });

            collectButton.addEventListener('click', collectResources);
            forgeCard.addEventListener('click', () => {
                forgePopup.style.display = 'block';
            });

            forgeButton.addEventListener('click', tryForge);

            const forgeSlots = document.querySelectorAll('.forgeSlot');
            forgeSlots.forEach(slot => {
                slot.addEventListener('dragover', (e) => {
                    e.preventDefault();
                });
                slot.addEventListener('drop', onDrop);
            });

            moveTileButton.addEventListener('click', toggleMoveTileMode);
            collectAllButton.addEventListener('click', collectAllResources);
            roadBuildingButton.addEventListener('click', toggleRoadBuildingMode);
            startCombatButton.addEventListener('click', startCombat);
            collectRewardButton.addEventListener('click', collectCombatReward);

            gameClock.addEventListener('contextmenu', showSaveLoadPopup);
            gameClock.addEventListener('touchstart', handleClockLongPress);

            saveButton.addEventListener('click', saveGame);
            loadButton.addEventListener('click', () => loadFile.click());
            loadFile.addEventListener('change', loadGame);
            newGameButton.addEventListener('click', startNewGame);

            recipeButton.addEventListener('click', showRecipes);
            clearForgeButton.addEventListener('click', clearForgeSlots);

            // Initialize starting avatars
            avatars = [
                { emoji: 'üë§', race: 'Human', hp: 6, attack: 4, defense: 4, mana: 4, luck: 4, equipment: [] },
                { emoji: 'üßî', race: 'Dwarf', hp: 6, attack: 4, defense: 4, mana: 4, luck: 4, equipment: [] },
                { emoji: 'üßù', race: 'Elf', hp: 6, attack: 4, defense: 4, mana: 4, luck: 4, equipment: [] }
            ];

            // Load game from cookie if exists
            const savedGame = localStorage.getItem('infiniteTerrainSave');
            if (savedGame) {
                const gameState = JSON.parse(savedGame);
                mapData = gameState.mapData;
                resources = gameState.resources;
                avatars = gameState.avatars;
                gameTime = gameState.gameTime;
                updateResourceBar();
                drawMap();
                logEvent('Game loaded from cookie.');
            }

            requestAnimationFrame(gameLoop);
        }

        function gameLoop() {
            const currentTime = Date.now();
            const deltaTime = (currentTime - lastUpdateTime) / 1000; // Convert to seconds
            lastUpdateTime = currentTime;

            updateGameTime(deltaTime);
            drawMap();

            requestAnimationFrame(gameLoop);
        }

        function updateGameTime(deltaTime) {
            gameTime += deltaTime * 5; // 2 real seconds = 10 game minutes
            const totalMinutes = Math.floor(gameTime);
            const years = Math.floor(totalMinutes / (365 * 24 * 60));
            const days = Math.floor((totalMinutes % (365 * 24 * 60)) / (24 * 60));
            const hours = Math.floor((totalMinutes % (24 * 60)) / 60);
            const minutes = Math.floor(totalMinutes % 60);
            const clockEmoji = clockEmojis[hours % 24];
            gameClock.textContent = `${clockEmoji} (${years}‚Ä¢${days}) ${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;

            // Check for resource regeneration
            if (Math.floor(gameTime / 60) % 8 === 0 && Math.floor(gameTime % 60) === 0) {
                regenerateResources();
            }

            // Update background color based on game time
            updateBackgroundColor(hours, minutes);

            // Move travelers on roads
            if (hours >= 6 && hours < 18) {
                moveTravelers();
            }
        }

        function updateBackgroundColor(hours, minutes) {
            let color;
            const time = hours + minutes / 60;

            if (time >= 0 && time <= 6) {
                color = 'rgba(20, 20, 20, 0.8)'; // Slightly light black
            } else if (time > 6 && time <= 8) {
                color = 'rgba(255, 255, 200, 0.8)'; // Light yellow
            } else if (time > 8 && time <= 17) {
                color = 'rgba(255, 255, 255, 0.8)'; // White
            } else if (time > 17 && time <= 22) {
                color = 'rgba(128, 128, 128, 0.8)'; // Medium grey
            } else {
                color = 'rgba(20, 20, 20, 0.8)'; // Slightly light black
            }

            document.body.style.backgroundColor = color;
        }

        function regenerateResources() {
            for (const key in mapData) {
                const tile = mapData[key];
                if (tile.hasGeneratedResources) {
                    tile.hasGeneratedResources = false;
                }
            }
        }

        function startGame() {
            gameStarted = true;
            startMenu.style.display = 'none';
            drawMap();
        }

        readyButton.addEventListener('click', startGame);

        function dealCards(count) {
            hand.innerHTML = '';
            for (let i = 0; i < count; i++) {
                const card = document.createElement('div');
                card.className = 'card';
                const terrain = terrainTypes[Math.floor(Math.random() * terrainTypes.length)];
                card.textContent = terrain.emoji;
                card.dataset.terrain = JSON.stringify(terrain);
                card.addEventListener('click', selectCard);
                hand.appendChild(card);
            }
        }

        function selectCard(e) {
            if (selectedCard) selectedCard.style.border = '1px solid #333';
            selectedCard = e.target;
            selectedCard.style.border = '1px solid #ff0000';
            logEvent(`Selected ${JSON.parse(selectedCard.dataset.terrain).name} card`);
        }

        function onCanvasClick(e) {
            if (isRoadBuildingMode) {
                handleRoadBuilding(e);
                return;
            }

            if (isMoveTileMode) {
                handleMoveTile(e);
                return;
            }

            if (!selectedCard) {
                const rect = canvas.getBoundingClientRect();
                const x = Math.floor((e.clientX - rect.left - cameraOffset.x) / (tileSize * cameraZoom));
                const y = Math.floor((e.clientY - rect.top - cameraOffset.y) / (tileSize * cameraZoom));
                const key = `${x},${y}`;
                if (mapData[key]) {
                    showTileInfo(x, y);
                }
                return;
            }

            const rect = canvas.getBoundingClientRect();
            const x = Math.floor((e.clientX - rect.left - cameraOffset.x) / (tileSize * cameraZoom));
            const y = Math.floor((e.clientY - rect.top - cameraOffset.y) / (tileSize * cameraZoom));

            placeTile(x, y, JSON.parse(selectedCard.dataset.terrain));
            selectedCard.remove();
            selectedCard = null;

            if (hand.children.length === 0) {
                dealCards(7);
                checkForEvents();
            }

            drawMap();
        }

        function placeTile(x, y, terrain) {
            const key = `${x},${y}`;
            mapData[key] = { ...terrain, hasGeneratedResources: false };
            checkForLargeGroup(x, y);

            // Check for Avatar (1 in 25 chance)
            if (Math.random() < 0.04) {
                const avatar = generateAvatar();
                mapData[key].avatar = avatar;
                logEvent(`An Avatar (${avatar.emoji} ${avatar.race}) has appeared on the ${terrain.name} tile!`);
                avatars.push(avatar);
            }

            // Check for Monster Camp (1 in 15 chance)
            if (Math.random() < 0.0667) {
                mapData[key] = { ...events.find(e => e.name === 'Monster Camp'), monsterCount: Math.floor(Math.random() * 6) + 1 };
                logEvent(`A Monster Camp has appeared on the ${terrain.name} tile!`);
            }

            // Check for Treasure (1 in 25 chance)
            if (Math.random() < 0.04) {
                const treasureResources = getTreasureResources();
                Object.entries(treasureResources).forEach(([resource, amount]) => {
                    resources[resource] = (resources[resource] || 0) + amount;
                });
                logEvent(`A treasure chest was found on the ${terrain.name} tile! You received: ${Object.entries(treasureResources).map(([r, a]) => `${a} ${r}`).join(', ')}`);
                updateResourceBar();
            }

            // Check for Town (1 in 25 chance)
            if (Math.random() < 0.04) {
                mapData[key] = { emoji: 'üõñ', name: 'Town', resourceMultiplier: 2, goldGeneration: 10 };
                logEvent(`A Town has been discovered on the ${terrain.name} tile!`);}

            // Suggest best tile placement
            suggestBestTilePlacement(x, y, terrain.name);

            // Check for resource combination
            checkResourceCombination(x, y);
        }

        function suggestBestTilePlacement(x, y, terrainName) {
            const bestCombinations = tileResourceCombinations[terrainName];
            if (!bestCombinations) return;

            const directions = [
                { dx: 1, dy: 0 },
                { dx: -1, dy: 0 },
                { dx: 0, dy: 1 },
                { dx: 0, dy: -1 }
            ];

            for (const { dx, dy } of directions) {
                const newX = x + dx;
                const newY = y + dy;
                const newKey = `${newX},${newY}`;

                if (!mapData[newKey]) {
                    const suggestedTerrain = terrainTypes.find(t => bestCombinations.includes(t.name));
                    if (suggestedTerrain) {
                        ctx.globalAlpha = 0.5;
                        ctx.fillStyle = '#90EE90';
                        ctx.fillRect(newX * tileSize, newY * tileSize, tileSize, tileSize);
                        ctx.globalAlpha = 1;
                        ctx.font = `${tileSize * 0.7}px Arial`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(suggestedTerrain.emoji, newX * tileSize + tileSize / 2, newY * tileSize + tileSize / 2);
                    }
                }
            }
        }

        function checkResourceCombination(x, y) {
            const currentTile = mapData[`${x},${y}`];
            if (!currentTile) return;

            const directions = [
                { dx: 1, dy: 0 },
                { dx: -1, dy: 0 },
                { dx: 0, dy: 1 },
                { dx: 0, dy: -1 }
            ];

            for (const { dx, dy } of directions) {
                const neighborX = x + dx;
                const neighborY = y + dy;
                const neighborKey = `${neighborX},${neighborY}`;
                const neighborTile = mapData[neighborKey];

                if (neighborTile && tileResourceCombinations[currentTile.name]?.includes(neighborTile.name)) {
                    currentTile.backgroundColor = 'blue';
                    neighborTile.backgroundColor = 'blue';
                    logEvent(`Resource combination found: ${currentTile.name} and ${neighborTile.name}`);
                }
            }
        }

        function generateAvatar() {
            const races = ['Human', 'Elf', 'Dwarf', 'Orc', 'Gnome', 'Halfling', 'Fairy', 'Goblin'];
            return {
                emoji: avatarEmojis[Math.floor(Math.random() * avatarEmojis.length)],
                race: races[Math.floor(Math.random() * races.length)],
                hp: Math.floor(Math.random() * 8) + 3,
                attack: Math.floor(Math.random() * 8) + 3,
                defense: Math.floor(Math.random() * 8) + 3,
                mana: Math.floor(Math.random() * 8) + 3,
                luck: Math.floor(Math.random() * 8) + 3,
                equipment: []
            };
        }

        function getTreasureResources() {
            const allResources = terrainTypes.map(t => t.resource);
            const treasureResources = {};
            for (let i = 0; i < 4; i++) {
                const resource = allResources[Math.floor(Math.random() * allResources.length)];
                treasureResources[resource] = (treasureResources[resource] || 0) + Math.floor(Math.random() * 11) + 5; // 5-15 resources
            }
            return treasureResources;
        }

        function checkForLargeGroup(x, y) {
            const directions = [
                [-1, -1], [0, -1], [1, -1],
                [-1, 0], [0, 0], [1, 0],
                [-1, 1], [0, 1], [1, 1]
            ];

            for (let [dx, dy] of directions) {
                const newX = x + dx;
                const newY = y + dy;
                const groupSize = checkGroupAt(newX, newY);
                if (groupSize) {
                    const groupKeys = getGroupKeys(newX, newY, groupSize);
                    groupKeys.forEach(key => {
                        mapData[key].isPartOfLargeGroup = true;
                        mapData[key].groupSize = groupSize;
                        mapData[key].resourceMultiplier = 1 + (groupSize.width * groupSize.height - 1) * 3;
                    });
                    break;
                }
            }
        }

        function checkGroupAt(x, y) {
            const type = mapData[`${x},${y}`]?.name;
            if (!type) return null;

            let maxWidth = 1;
            let maxHeight = 1;

            // Check width
            while (mapData[`${x + maxWidth},${y}`]?.name === type && maxWidth < 4) {
                maxWidth++;
            }

            // Check height
            while (mapData[`${x},${y + maxHeight}`]?.name === type && maxHeight < 4) {
                maxHeight++;
            }

            // Verify the entire rectangle
            for (let i = 0; i < maxWidth; i++) {
                for (let j = 0; j < maxHeight; j++) {
                    if (mapData[`${x + i},${y + j}`]?.name !== type) {
                        return null;
                    }
                }
            }

            return { width: maxWidth, height: maxHeight };
        }

        function getGroupKeys(x, y, size) {
            const keys = [];
            for (let i = 0; i < size.width; i++) {
                for (let j = 0; j < size.height; j++) {
                    keys.push(`${x + i},${y + j}`);
                }
            }
            return keys;
        }

        function checkForEvents() {
            const eventChance = 0.3;
            if (Math.random() < eventChance) {
                const event = events[Math.floor(Math.random() * events.length)];
                logEvent(`${event.emoji} ${event.description}`);
                dealCards(3); // Reward for event
            }
        }

        function logEvent(message) {
            const entry = document.createElement('div');
            entry.textContent = message;
            entry.addEventListener('click', () => highlightRelatedTile(message));
            eventLog.appendChild(entry);
            eventLog.scrollTop = eventLog.scrollHeight;
        }

        function highlightRelatedTile(message) {
            const keywords = ['Monster Camp', 'Town', 'Dwarf Cave'];
            const keyword = keywords.find(k => message.includes(k));
            if (keyword) {
                for (const key in mapData) {
                    if (mapData[key].name === keyword) {
                        const [x, y] = key.split(',').map(Number);
                        highlightTile(x, y);
                        break;
                    }
                }
            }
        }

        function highlightTile(x, y) {
            ctx.save();
            ctx.globalAlpha = 0.5;
            ctx.fillStyle = 'yellow';
            ctx.fillRect(x * tileSize, y * tileSize, tileSize, tileSize);
            ctx.restore();
            setTimeout(() => drawMap(), 1000); // Remove highlight after 1 second
        }

        function drawMap() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.save();
            ctx.translate(cameraOffset.x, cameraOffset.y);
            ctx.scale(cameraZoom, cameraZoom);

            const startX = Math.floor(-cameraOffset.x / (tileSize * cameraZoom));
            const startY = Math.floor(-cameraOffset.y / (tileSize * cameraZoom));
            const endX = startX + Math.ceil(canvas.width / (tileSize * cameraZoom));
            const endY = startY + Math.ceil(canvas.height / (tileSize * cameraZoom));

            for (let x = startX; x <= endX; x++) {
                for (let y = startY; y <= endY; y++) {
                    const key = `${x},${y}`;
                    if (mapData[key]) {
                        if (mapData[key].isPartOfLargeGroup) {
                            const hue = (gameTime * 10) % 360; // Change color over time
                            ctx.fillStyle = `hsl(${hue}, 100%, 80%)`;
                        } else if (mapData[key].hasGeneratedResources) {
                            ctx.fillStyle = 'transparent';
                        } else {
                            ctx.fillStyle = mapData[key].backgroundColor || (mapData[key].avatar ? 'gold' : '#e0e0e0');
                        }
                        ctx.fillRect(x * tileSize, y * tileSize, tileSize, tileSize);
                        ctx.font = `${tileSize * 0.7}px Arial`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillStyle = 'black';
                        ctx.fillText(mapData[key].emoji, x * tileSize + tileSize / 2, y * tileSize + tileSize / 2);

                        if (mapData[key].avatar) {
                            ctx.font = `${tileSize * 0.4}px Arial`;
                            ctx.fillText(mapData[key].avatar.emoji, x * tileSize + tileSize * 0.8, y * tileSize + tileSize * 0.8);
                        }

                        if (mapData[key].traveler) {
                            ctx.font = `${tileSize * 0.4}px Arial`;
                            ctx.fillText(mapData[key].traveler, x * tileSize + tileSize * 0.2, y * tileSize + tileSize * 0.2);
                        }
                    } else {
                        ctx.strokeStyle = '#ccc';
                        ctx.strokeRect(x * tileSize, y * tileSize, tileSize, tileSize);
                    }
                }
            }

            ctx.restore();
        }

        function onMouseDown(e) {
            isDragging = true;
            dragStart = { x: e.clientX - cameraOffset.x, y: e.clientY - cameraOffset.y };
        }

        function onMouseMove(e) {
            if (isDragging) {
                cameraOffset.x = e.clientX - dragStart.x;
                cameraOffset.y = e.clientY - dragStart.y;
                drawMap();
            }
        }

        function onMouseUp() {
            isDragging = false;
        }

        function onWheel(e) {
            e.preventDefault();
            adjustZoom(e.deltaY * -0.001);
        }

        function adjustZoom(zoomAmount) {
            cameraZoom += zoomAmount;
            cameraZoom = Math.min(Math.max(0.1, cameraZoom), 10);
            drawMap();
        }

        function onTouchStart(e) {
            if (e.touches.length === 1) {
                isDragging = true;
                dragStart = { x: e.touches[0].clientX - cameraOffset.x, y: e.touches[0].clientY - cameraOffset.y };
            } else if (e.touches.length === 2) {
                isDragging = false;
                lastZoomPinchDistance = getDistance(e.touches[0], e.touches[1]);
            }
        }

        function onTouchMove(e) {
            e.preventDefault();
            if (isDragging && e.touches.length === 1) {
                cameraOffset.x = e.touches[0].clientX - dragStart.x;
                cameraOffset.y = e.touches[0].clientY - dragStart.y;
                drawMap();
            } else if (e.touches.length === 2) {
                const newDistance = getDistance(e.touches[0], e.touches[1]);
                const zoomAmount = (newDistance - lastZoomPinchDistance) * 0.01;
                adjustZoom(zoomAmount);
                lastZoomPinchDistance = newDistance;
            }
        }

        function onTouchEnd() {
            isDragging = false;
        }

        function getDistance(touch1, touch2) {
            return Math.hypot(touch1.clientX - touch2.clientX, touch1.clientY - touch2.clientY);
        }

        function showTileInfo(x, y) {
            const key = `${x},${y}`;
            const tile = mapData[key];
            if (!tile) return;

            let content = `<h3>${tile.emoji} ${tile.name}</h3>`;
            content += `<p>Type: ${tile.name}</p>`;

            if (tile.name === 'Monster Camp') {
                showCombatPopup(x, y);
                return;
            }

            if (tile.resource) {
                content += `<p>Resource: ${tile.resource}</p>`;

                if (!tile.hasGeneratedResources) {
                    const resourceAmount = tile.isPartOfLargeGroup ? tile.resourceMultiplier : 1;
                    content += `<p>Available resources: ${resourceAmount} ${tile.resource}</p>`;
                } else {
                    content += `<p>Resources already collected</p>`;
                }
            }

            if (tile.avatar) {
                content += `<p>Avatar: ${tile.avatar.emoji} (${tile.avatar.race})</p>`;
                content += `<button id="recruitAvatar">Recruit Avatar</button>`;
            }

            if (tile.name === 'Town') {
                content += `<p>Resource multiplier: ${tile.resourceMultiplier}x</p>`;
                content += `<p>Gold generation: +${tile.goldGeneration}</p>`;
            }

            popupContent.innerHTML = content;
            popupBox.style.display = 'block';
            collectButton.style.display = tile.hasGeneratedResources ? 'none' : 'block';
            collectButton.dataset.x = x;
            collectButton.dataset.y = y;

            if (tile.avatar) {
                document.getElementById('recruitAvatar').addEventListener('click', () => recruitAvatar(x, y));
            }
        }

        function collectResources() {
            const x = parseInt(collectButton.dataset.x);
            const y = parseInt(collectButton.dataset.y);
            const key = `${x},${y}`;
            const tile = mapData[key];

            if (tile && !tile.hasGeneratedResources) {
                let resourceAmount = tile.isPartOfLargeGroup ? tile.resourceMultiplier : 1;
                if (tile.name === 'Town') {
                    resourceAmount *= tile.resourceMultiplier;
                    resources['Gold'] = (resources['Gold'] || 0) + tile.goldGeneration;
                }
                resources[tile.resource] = (resources[tile.resource] || 0) + resourceAmount;
                tile.hasGeneratedResources = true;
                updateResourceBar();
                showTileInfo(x, y);
            }
        }

        function updateResourceBar() {
            resourceBar.innerHTML = '';
            const resourceBarHeight = window.innerHeight - 20; // Subtract some padding
            const cardHeight = 40; // Height of each resource card
            const maxCards = Math.floor(resourceBarHeight / cardHeight);
            
            const resourceEntries = Object.entries(resources);
            for (let i = 0; i < Math.min(maxCards, resourceEntries.length); i++) {
                const [resource, amount] = resourceEntries[i];
                const resourceCard = document.createElement('div');
                resourceCard.className = 'resourceCard';
                const emoji = resource === 'Gold' ? 'ü™ô' : terrainTypes.find(t => t.resource === resource)?.emoji;
                resourceCard.innerHTML = `${emoji}<br>${amount}`;
                resourceCard.draggable = true;
                resourceCard.addEventListener('dragstart', (e) => {
                    e.dataTransfer.setData('text/plain', resource);
                });
                resourceCard.addEventListener('click', () => addResourceToForge(resource));
                resourceBar.appendChild(resourceCard);
            }

            if (resourceEntries.length > maxCards) {
                const moreResources = document.createElement('div');
                moreResources.className = 'resourceCard';
                moreResources.textContent = '...';
                moreResources.title = 'More resources available';
                resourceBar.appendChild(moreResources);
            }
        }

        function addResourceToForge(resource) {
            if (forgePopup.style.display === 'block') {
                const slots = document.querySelectorAll('.forgeSlot');
                for (let i = 0; i < 2; i++) {
                    if (!slots[i].dataset.resource) {
                        slots[i].textContent = resource === 'Gold' ? 'ü™ô' : terrainTypes.find(t => t.resource === resource)?.emoji;
                        slots[i].dataset.resource = resource;
                        checkForgeRecipe();
                        break;
                    }
                }
            }
        }

        function onDrop(e) {
            e.preventDefault();
            const resource = e.dataTransfer.getData('text');
            e.target.textContent = resource === 'Gold' ? 'ü™ô' : terrainTypes.find(t => t.resource === resource)?.emoji;
            e.target.dataset.resource = resource;
            checkForgeRecipe();
        }

        function checkForgeRecipe() {
            const slots = document.querySelectorAll('.forgeSlot');
            const ingredients = Array.from(slots).slice(0, 2).map(slot => slot.dataset.resource).filter(Boolean);

            const recipe = recipes.find(r => 
                r.inputs.length === ingredients.length && 
                r.inputs.every(i => ingredients.includes(i))
            );

            if (recipe) {
                slots[2].textContent = recipe.outputEmoji;
                slots[2].dataset.resource = recipe.output;
                forgeButton.textContent = recipe.outputEmoji;
                forgeButton.dataset.recipe = JSON.stringify(recipe);
            } else {
                slots[2].textContent = 'üö´';
                slots[2].dataset.resource = '';
                forgeButton.textContent = '‚öíÔ∏è';
                forgeButton.dataset.recipe = '';
            }
        }

        function tryForge() {
            const recipe = JSON.parse(forgeButton.dataset.recipe || 'null');
            if (recipe) {
                recipe.inputs.forEach(ingredient => {
                    resources[ingredient]--;
                    if (resources[ingredient] === 0) {
                        delete resources[ingredient];
                    }
                });

                resources[recipe.output] = (resources[recipe.output] || 0) + 1;

                updateResourceBar();
                clearForgeSlots();
                logEvent(`Forged ${recipe.output}!`);
            } else {
                // Highlight possible combinations
                const possibleIngredients = new Set(recipes.flatMap(r => r.inputs));
                const resourceCards = document.querySelectorAll('.resourceCard');
                resourceCards.forEach(card => {
                    const resourceType = card.textContent.split('\n')[0];
                    if (possibleIngredients.has(terrainTypes.find(t => t.emoji === resourceType)?.resource)) {
                        card.style.border = '2px solid green';
                    }
                });

                setTimeout(() => {
                    resourceCards.forEach(card => {
                        card.style.border = '1px solid #333';
                    });
                }, 2000);
            }
        }

        function clearForgeSlots() {
            const slots = document.querySelectorAll('.forgeSlot');
            slots.forEach(slot => {
                slot.textContent = '';
                slot.dataset.resource = '';
            });
            forgeButton.textContent = '‚öíÔ∏è';
            forgeButton.dataset.recipe = '';
        }

        function recruitAvatar(x, y) {
            const key = `${x},${y}`;
            const tile = mapData[key];
            if (tile && tile.avatar) {
                avatars.push(tile.avatar);
                delete tile.avatar;
                logEvent(`Recruited a new Avatar: ${tile.avatar.emoji} (${tile.avatar.race})`);
                showTileInfo(x, y);
                drawMap();
            }
        }

        function toggleMoveTileMode() {
            isMoveTileMode = !isMoveTileMode;
            moveTileButton.style.backgroundColor = isMoveTileMode ? '#ff0000' : '#f0f0f0';
            if (isMoveTileMode) {
                logEvent("Move tile mode activated. Select a tile to move.");
            } else {
                logEvent("Move tile mode deactivated.");
                tileToMove = null;
            }
        }

        function handleMoveTile(e) {
            const rect = canvas.getBoundingClientRect();
            const x = Math.floor((e.clientX - rect.left - cameraOffset.x) / (tileSize * cameraZoom));
            const y = Math.floor((e.clientY - rect.top - cameraOffset.y) / (tileSize * cameraZoom));
            const key = `${x},${y}`;

            if (!tileToMove) {
                if (mapData[key]) {
                    tileToMove = { x, y, tile: mapData[key] };
                    logEvent("Tile selected. Now select the destination.");
                }
            } else {
                if (resources['Gold'] >= 10) {
                    resources['Gold'] -= 10;
                    delete mapData[`${tileToMove.x},${tileToMove.y}`];
                    mapData[key] = tileToMove.tile;
                    logEvent(`Tile moved from (${tileToMove.x}, ${tileToMove.y}) to (${x}, ${y}). 10 Gold spent.`);
                    updateResourceBar();
                    drawMap();
                    isMoveTileMode = false;
                    moveTileButton.style.backgroundColor = '#f0f0f0';
                    tileToMove = null;
                } else {
                    logEvent("Not enough Gold to move tile. 10 Gold required.");
                }
            }
        }

        function collectAllResources() {
            const currentGameHours = Math.floor(gameTime / 60);
            if (currentGameHours - lastCollectAllTime >= 8) {
                let totalCollected = 0;
                let newAvatars = 0;

                for (const key in mapData) {
                    const tile = mapData[key];
                    if (!tile.hasGeneratedResources && tile.resource) {
                        let resourceAmount = tile.isPartOfLargeGroup ? tile.resourceMultiplier : 1;
                        if (tile.name === 'Town') {
                            resourceAmount *= tile.resourceMultiplier;
                            resources['Gold'] = (resources['Gold'] || 0) + tile.goldGeneration;
                        }
                        resources[tile.resource] = (resources[tile.resource] || 0) + resourceAmount;
                        tile.hasGeneratedResources = true;
                        totalCollected += resourceAmount;
                    }
                    if (tile.avatar) {
                        avatars.push(tile.avatar);
                        delete tile.avatar;
                        newAvatars++;
                    }
                }

                updateResourceBar();
                drawMap();

                let message = `Collected ${totalCollected} resources from all tiles.`;
                if (newAvatars > 0) {
                    message += ` Recruited ${newAvatars} new Avatar${newAvatars > 1 ? 's' : ''}!`;
                }
                logEvent(message);

                lastCollectAllTime = currentGameHours;
            } else {
                logEvent("Not enough time has passed to collect all resources. Please wait.");
            }
        }

        function toggleRoadBuildingMode() {
            isRoadBuildingMode = !isRoadBuildingMode;
            roadBuildingButton.style.backgroundColor = isRoadBuildingMode ? '#ff0000' : '#f0f0f0';
            if (isRoadBuildingMode) {
                logEvent("Road building mode activated. Select start and end points.");
            } else {
                logEvent("Road building mode deactivated.");
                roadStartTile = null;
                roadEndTile = null;
            }
        }

        function handleRoadBuilding(e) {
            const rect = canvas.getBoundingClientRect();
            const x = Math.floor((e.clientX - rect.left - cameraOffset.x) / (tileSize * cameraZoom));
            const y = Math.floor((e.clientY - rect.top - cameraOffset.y) / (tileSize * cameraZoom));
            
            if (!roadStartTile) {
                roadStartTile = { x, y };
                logEvent("Start point selected. Now select the end point.");
            } else if (!roadEndTile) {
                roadEndTile = { x, y };
                buildRoad(roadStartTile, roadEndTile);
                roadStartTile = null;
                roadEndTile = null;
                isRoadBuildingMode = false;
                roadBuildingButton.style.backgroundColor = '#f0f0f0';
            }
        }

        function buildRoad(start, end) {
            const path = findPath(start, end);
            if (path) {
                let roadCost = path.length - 1; // Subtract 1 to exclude the start tile
                if (resources['Road'] >= roadCost) {
                    resources['Road'] -= roadCost;
                    for (let i = 1; i < path.length; i++) { // Start from 1 to exclude the start tile
                        const { x, y } = path[i];
                        const key = `${x},${y}`;
                        mapData[key] = { emoji: i === path.length - 1 ? '‚ûï' : '‚ûñ', name: 'Road' };
                    }
                    updateResourceBar();
                    drawMap();
                    logEvent(`Road built successfully! Used ${roadCost} road segments.`);
                } else {
                    logEvent(`Not enough road segments. Need ${roadCost}, have ${resources['Road'] || 0}.`);
                }
            } else {
                logEvent("Unable to find a valid path for the road.");
            }
        }

        function findPath(start, end) {
            const queue = [[start]];
            const visited = new Set();

            while (queue.length > 0) {
                const path = queue.shift();
                const { x, y } = path[path.length - 1];

                if (x === end.x && y === end.y) {
                    return path;
                }

                const key = `${x},${y}`;
                if (!visited.has(key)) {
                    visited.add(key);

                    const neighbors = [
                        { x: x + 1, y },
                        { x: x - 1, y },
                        { x, y: y + 1 },
                        { x, y: y - 1 }
                    ];

                    for (const neighbor of neighbors) {
                        const neighborKey = `${neighbor.x},${neighbor.y}`;
                        if (!visited.has(neighborKey) && (!mapData[neighborKey] || mapData[neighborKey].name === 'Road')) {
                            queue.push([...path, neighbor]);
                        }
                    }
                }
            }

            return null; // No path found
        }

        function moveTravelers() {
            const travelers = ['üö∂', 'üß≥'];
            const roads = Object.entries(mapData).filter(([_, tile]) => tile.name === 'Road');

            if (roads.length === 0) return;

            // Remove existing travelers
            for (const key in mapData) {
                if (mapData[key].traveler) {
                    delete mapData[key].traveler;
                }
            }

            // Add new travelers
            const numTravelers = Math.min(Math.floor(roads.length / 5) + 1, 5); // Add more travelers as roads increase
            for (let i = 0; i < numTravelers; i++) {
                const [startKey] = roads[Math.floor(Math.random() * roads.length)];
                const [x, y] = startKey.split(',').map(Number);
                const traveler = travelers[Math.floor(Math.random() * travelers.length)];
                mapData[startKey].traveler = traveler;

                // Move traveler along the road
                setTimeout(() => moveTravelerAlongRoad(x, y, traveler), i * 1000);
            }
        }

        function moveTravelerAlongRoad(x, y, traveler) {
            const key = `${x},${y}`;
            if (!mapData[key] || mapData[key].name !== 'Road') return;

            mapData[key].traveler = traveler;
            drawMap();

            const directions = [
                { dx: 1, dy: 0 },
                { dx: -1, dy: 0 },
                { dx: 0, dy: 1 },
                { dx: 0, dy: -1 }
            ];

            const validDirections = directions.filter(({ dx, dy }) => {
                const newKey = `${x + dx},${y + dy}`;
                return mapData[newKey] && mapData[newKey].name === 'Road';
            });

            if (validDirections.length > 0) {
                const { dx, dy } = validDirections[Math.floor(Math.random() * validDirections.length)];
                delete mapData[key].traveler;
                setTimeout(() => moveTravelerAlongRoad(x + dx, y + dy, traveler), 1000);
            } else {
                delete mapData[key].traveler;
                drawMap();
            }
        }

        function showCombatPopup(x, y) {
            const key = `${x},${y}`;
            const tile = mapData[key];
            
            monsterCountElement.textContent = `Monsters: ${tile.monsterCount}`;
            
            avatarSelectionElement.innerHTML = '';
            avatars.forEach((avatar, index) => {
                const avatarButton = document.createElement('button');
                avatarButton.textContent = `${avatar.emoji} ${avatar.race}`;
                avatarButton.addEventListener('click', () => selectAvatarForCombat(index, x, y));
                avatarSelectionElement.appendChild(avatarButton);
            });

            startCombatButton.style.display = 'none';
            collectRewardButton.style.display = 'none';
            combatLogElement.innerHTML = '';

            combatPopup.style.display = 'block';
        }

        function selectAvatarForCombat(avatarIndex, x, y) {
            const avatar = avatars[avatarIndex];
            startCombatButton.dataset.avatarIndex = avatarIndex;
            startCombatButton.dataset.x = x;
            startCombatButton.dataset.y = y;
            startCombatButton.style.display = 'block';
            logEvent(`Selected ${avatar.emoji} ${avatar.race} for combat.`);
        }

        function startCombat() {
            const avatarIndex = startCombatButton.dataset.avatarIndex;
            const x = startCombatButton.dataset.x;
            const y = startCombatButton.dataset.y;
            const key = `${x},${y}`;
            const tile = mapData[key];
            const avatar = avatars[avatarIndex];

            let combatLog = '';
            let avatarHP = avatar.hp;
            let monstersRemaining = tile.monsterCount;

            while (avatarHP > 0 && monstersRemaining > 0) {
                // Avatar's turn
                const avatarDamage = Math.max(0, avatar.attack - Math.floor(Math.random() * 3));
                monstersRemaining = Math.max(0, monstersRemaining - 1);
                combatLog += `${avatar.emoji} deals ${avatarDamage} damage. ${monstersRemaining} monsters remaining.<br>`;

                if (monstersRemaining === 0) break;

                // Monsters' turn
                const monsterDamage = Math.max(0, 2 - avatar.defense + Math.floor(Math.random() * 3));
                avatarHP = Math.max(0, avatarHP - monsterDamage);
                combatLog += `Monsters deal ${monsterDamage} damage. ${avatar.emoji} has ${avatarHP} HP left.<br>`;
            }

            combatLogElement.innerHTML = combatLog;

            if (avatarHP > 0) {
                logEvent(`${avatar.emoji} ${avatar.race} defeated the monster camp!`);
                startCombatButton.style.display = 'none';
                collectRewardButton.style.display = 'block';
                collectRewardButton.dataset.x = x;
                collectRewardButton.dataset.y = y;
            } else {
                logEvent(`${avatar.emoji} ${avatar.race} was defeated by the monsters.`);
                avatars.splice(avatarIndex, 1);
                startCombatButton.style.display = 'none';
            }
        }

        function collectCombatReward() {
            const x = collectRewardButton.dataset.x;
            const y = collectRewardButton.dataset.y;
            const key = `${x},${y}`;
            const tile = mapData[key];

            const goldReward = Math.floor(Math.random() * 3 * tile.monsterCount) + tile.monsterCount;
            resources['Gold'] = (resources['Gold'] || 0) + goldReward;

            delete mapData[key];
            updateResourceBar();
            drawMap();

            logEvent(`Collected ${goldReward} gold from the defeated monster camp.`);
            combatPopup.style.display = 'none';
        }

        function showRecipes() {
            recipesList.innerHTML = '';
            recipes.forEach(recipe => {
                const recipeItem = document.createElement('div');
                const inputEmojis = recipe.inputs.map(input => {
                    return input === 'Gold' ? 'ü™ô' : terrainTypes.find(t => t.resource === input)?.emoji;
                }).join(' + ');
                recipeItem.textContent = `${inputEmojis} = ${recipe.outputEmoji}`;
                recipesList.appendChild(recipeItem);
            });
            recipesPopup.style.display = 'block';
        }

        function handleClockLongPress(e) {
            e.preventDefault();
            let timer = setTimeout(() => {
                showSaveLoadPopup(e);
            }, 500);

            e.target.addEventListener('touchend', () => {
                clearTimeout(timer);
            }, { once: true });
        }

        function showSaveLoadPopup(e) {
            e.preventDefault();
            saveLoadPopup.style.display = 'block';
        }

        function saveGame() {
            const gameState = {
                mapData,
                resources,
                avatars,
                gameTime
            };

            const jsonString = JSON.stringify(gameState);
            localStorage.setItem('infiniteTerrainSave', jsonString);

            const blob = new Blob([jsonString], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'infinite_terrain_save.json';
            a.click();
            URL.revokeObjectURL(url);

            logEvent('Game saved successfully!');
        }

        function loadGame(e) {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(event) {
                    try {
                        const gameState = JSON.parse(event.target.result);
                        mapData = gameState.mapData;
                        resources = gameState.resources;
                        avatars = gameState.avatars;
                        gameTime = gameState.gameTime;

                        updateResourceBar();
                        drawMap();
                        logEvent('Game loaded successfully!');
                    } catch (error) {
                        logEvent('Error loading game: ' + error.message);
                    }
                };
                reader.readAsText(file);
            }
        }

        function startNewGame() {
            localStorage.removeItem('infiniteTerrainSave');
            location.reload();
        }

        initGame();
    </script>
</body>
</html>